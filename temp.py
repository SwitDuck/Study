# -*- coding: utf-8 -*-

#Неизменяемые типы - числа,строки,кортежи; изменяемые - списки и словари
##Присваивание кортежей
'''for (a,b,c) in [(1,2,3), (4,5,6), (7,8,9)]:
    print(b)
for ((a,b),c) in [((1,2),3), ((4,5),6), ((7,8),9)]:
    print(a)
'''

##range(n) - создание непрерывного списка чисел 1-n

##разделение последовательности на начальную и остальную части в цикле
""" L = list(range(10))
while L:
    front, L = L[0], L[1:]
    print(front, L)
"""

##Расширенная операция распаковывания(работает как с кортежами,числами,списками,строками)
'''
seq = [1,2,3,4]
a, *b = seq
print(a, b)
*a, b = seq
print(a, b)

#извлечение среза
S = 'spam'
S[0], S[1:3], S[3]
'''

##Экранирование последовательности
'''
\a
\b
\'
\\
\n
\f
'''
#path = r'C:\Users\Здравствуйте господи\Desktop\Новая папка\data.txt'
#print(path)
#print('try to {0} the {1}'.format('format', 'strings'))


#Спецификаторы формата
'''
В общем виде синтаксис использования спецификатора формата 
выглядит следующим образом:
    %[(name)][flags][width][.precision]code
Символ спецификатора формата (code) из табл. 7.4 располагается в самом кон-
це.
'''
'''
x = 1.23456789 
print('%e | %f | %g' % (x, x, x))
print('%E' % x)
'''
'''
reply = """                # Шаблон с замещаемыми спецификаторами формата
Greetings...
Hello %(name)s!
Your age squared is %(age)s
"""
values = {'name': 'Bob', 'age': 40}   
print(reply % values) 
'''

'''
Как и оператор форматирования %, метод format обладает дополнительными 
возможностями. Например, в строках формата допускается ссылаться на име-
на атрибутов объектов и ключи словарей, – как и в привычном синтаксисе 
языка PPyython, квадратные скобки обозначают ключи словаря, а точка приме-
няется для организации доступа к атрибутам объектов, на которые ссылаются 
позиционные или именованные спецификаторы
'''
'''
import sys
'My {1[spam]} runs {0.platform}'.format(sys, {'spam': 'laptop'})
print('My {config[spam]} runs {sys.platform}'.format(sys=sys, config={'spam': 'laptop'}))
'''

#Обьект кортеж tuple
'''
По сути это список который невозможно изменить.Необходимы когда треб фиксированные ассоциации обьектов.
Но это касается только самих кортежей, но не к обьектам которые он содержит.Т.е можно изменить вложенный обьект
T = (1,[2,3],4)
T[1][0] = 'spam'
Являются колекциями обьектов упорядоченных по позициям(слева направо).
Поддерживают все операции которые основаны на использовании смещения,такие как индексирование 
и извлечение среза.
Подобно спискам проще представлять как массивы ссылок на обьекты, кортежи хранят указатели на другие обьекты
а операция индексирования над ними выполняется очень быстро
T = () - пустой кортеж, T = ('abc', ('def', 'ghi')) - вложенный кортеж
Чтобы интерпретатор понял что это именно кортеж нужно после элемента поставить ',' т.е T=(1,)
'''
'''new_tuple = ('spam',3,4,5,[11,22,33])'''
'''
Операции над кортежами
T = tuple('spam') - создание кортежа из итерируемого обьекта
T[i], T[i][j], T[i:j]

len(T) - размер кортежа

T1+T2, T1*3 - конкатенация и повторение

Обход в цикле, проверка вхождения
for x in T : print(X)
'spam' in t2
[x**2 for x in T]

Поиск и подсчет вхождений
T.index(value) - первое вхождение в позиции value, T.index(value,value) - следующее вхождение за позицией value
T.count(value) - определить количество двоек в кортеже

создание списка из кортежа и кортежа из списка
tmp = list(T), T = tuple(tmp)

'''
'''Извлечцение среза'''
'''T = (1,2,3,4)
print(T[0], T[1:3])'''


#Файлы
'''
функция open() Обеспечивает свзязь с файлом,размещ на компе.

Операции над файлами
output = open(r'data.txt','w') - открывает файл для записи, w-запись
input = open('data', 'r') - открывает файл для чтения, r - чтение
aString = input.read() - чтение файла целиком в одну строку.
aString = input.read(N) - чтение следующих N символов(или байтов в строку)
aList = input.readlines() - чтение файла целиком в список строк(включая символ конца строки)
output.write(aString) - запись строки символов или байтов в файл
output.writelines(aList) - запись всех строк из списка в файл
output.close() - закрытие файла в ручную
output.flush() - выталкивает выходные буферы на диск, файл остается открытым
anyFile.seek(N) - изменяет текущую позицию в файле для следующей операции, смещая ее на N байтов от начала файла
for line in open('data.txt') - построчное чтение, в цикле
open('data.txt', encoding='latin-1') - файлы с текстом юникода(строки типа str)
open('data.bin', 'rb') - файлы с двоичными данными(строки типа bytes)
режим работы 'a' - файл открывается на запись в конец
если добавить к параметру режима работы b - то будет работа с двоичными данными
,а если + то можно будет как записывать так и читать данные
так же добавляя третий аргумент,управляющий буферизацией выводимих данных, например значение 0
будет означать что информация будет записываться в файл сразу же в момент вызова метода записи
лучше всего не использовать операцию чтения из файла, файлы имеют итератор который автоматически
читает информацию из файла строку за строкой в цикле for, в шенераторах списков и др итерац контекстах
метод seek позваоляет сценариям управлять позицией чтения и записи
\n - символ записи с новой строки, в конце
функция eval выполнит любовое выражение на python. Она предназначена для преобразует список и словарь(интерпретирует строку как програмный код)

Правильная обработка текста
file_path = r'C:\Users\Здравствуйте господи\Desktop\Новая папка\data.txt'
decoded_text = []
with open(file_path, 'rb') as file:
    for line in file: decoded_text.append(line.decode('unicode_escape'))
'''

###Сохранение обьектов с помощью модуля pickle
'''
Модуль pickle позволяет сохранять в файлах практически любые обьекты python без необх с нашей
стороны выполнять какие либо преобразования.Например сохранение словаря в файле:
D = {'a':1, 'b':2}
F=open('datafile.pkl', 'wb')
import pickle
pickle.dump(D,F)
F.close()
F=open('datafile.pkl', 'rb')
E = pickle.load(F)
Т.о мы получаем точно такой же обьект словаря без необх преобразования, т.е происходит сериализация
обьектов(преобраз обьектов в строку байтов и обратно)
Если выполнить open('datafile.plk', 'rb').read() то получим строку байтов
shelve - сохранение обьектов в файлах с доступом по ключу
'''

#Сохранение и интерпретация упакованных двоичных данных в файлах
'''
иногда приходится иметь дело с упакованными двоичными данными.Стандартная библиотека python 
позволяет сохранять и восстанавливать такие данные с помощью модуля struct
Пример:строка формата,которая определяет пакет данных содержащий 4-байтовое целое число, 4 символьную строку и 2 байтовое целое число
причем все представлены в формате следования байтов от старшего к младшему
import struct
F = open('data.bin', 'wb')
data = struct.pack('>i4sh', 7, b'spam', 8)
F.write(data)
F.close()
F = open('data.bin', 'rb')
data = F.read()  
F.close()
values = struct.unpack('>i4sh', data)
print(values)
'''

#Ссылки на обьекты
'''
Вот мы создали 2 списка и 1 словарь.L и D содержат ссылки на словарь X.
X = [1, 2, 3]
L = ['a', X, 'b']
D = {'x':X,'y':2}
Если внести изменения в X, то это приведет к изменению всех трех ссылок - X,L И D.
X[1]='surprise'
print(L)
print(D)
Ссылки более высокоуровненвый аналог указателей в других языках, эта особенность позволяет передавать
крупные обьекты между компонентами программы без выполнения дорогостоящей операции копирования.
В случае если нужно создать не ссылающуюся копию обьекта то можно использовать методы:
1) извлечение среза с пустыми пределами A = L[:]
2) словарей и множеств copy - B = D.copy()
однако copy создает поверхностные копии которые не копируют вложенные структуры данных, если
это нужно то использутется метод deepcopy
import copy
X = copy.deepcopy(Y)
'''

#Сравнивание,равенство и истина
'''
L1 = []
L2 = []
L1 == L2, L1 is L2 # == - интерпретатор выполняет проверку на равенство, рекурсивно сравнивая
все вложенные обьекты. is - проверяет являются ли сравниваемые обьекты одним и тем же обьектом.
сравнения <,==,>. строки сравниваются символ за символом, слева направо, 
словари сравниваются как отсортированные списки(ключ,значение)
однако в py 3.0 поддержка операторов отношений в словарях была ликвидирована.
Поэтому используются циклы.
list(D1.items()) < или > sorted(D2.items())

правда и ложь в python реализована как ложь - значения пустых списков/нули/None, правда - имеющих символы/1-9 цифры

'''

#Вывод текста,расширенное применение метода print
'''
print([object, ...][, sep=' '][, end='\n'][, file=sys.stdout])
здесь object - выводимые обьекты
sep - строка которая должна вставляться между выводимыми обьектами
end - строка добавляемая в конец выводимого текста
file - обьект файла,поток или другой обьект куда будет выводиться текст.
пример
print(x,y,z, sep=',', end='!\n', file=open('data.txt', 'w'))
print(open('data.txt').read())
стоит отметить что sys.stdout - параметр вывода по умолчанию
и его можно перенаправить в другое русло,например вывод в логи
import sys
sys.stdout = open('log.txt', 'a')
print(x,y,z)
sys.stdout.close()

или sys.stderr.write(('bad!'*8)+'\n') эквивалентно
print('bad!'*8, file=sys.stderr)
'''

#If и синтаксические правила
'''
if(условие):
    действие
elif(условие):
    действие
else:
    действие
логические операторы - and, or, not(and - если истина 2 значения, or - истина если любое,)

в случае оператора or интерпретатор начинает вычислять значения обьектов слева направо и 
возвращает первое истинное значение. Например 2 or 3, 3 or 2 - Вернет соответственно (2, 3)

and - останавливает вычисление когда найдется первый обьект имеющий ложное значение
краткая форма записи if/else
A = 't' if 'spam' else 'f'
A = 't' if '' else 'f'
Другая форма записи этих выражений
['f', 't'][bool('')]
['f', 't'][bool('spam')]
'''

#Циклы while и for
'''
while <test1>:
    <statements1>
    if <test2>: break
    if <test3>: continue
else:
    <statements2>
'''
#for
'''
циклы удобно использовать там где надо повторно выполнять некоторые действия или обрабатывать
данные. Вот пример посимвольного чтения.
file = open('test.txt')
while True:
    char = file.read(1)
    if not char: break
    print(char)
for char in open('test.txt').read()
    print(char)
Чтение строками или блоками
file = open('test.txt')
while True:
    line = file.readline()
    if not line:break
    print(line, end=' ')
file.close

file = open('test.txt', 'rb')
while True:
    chunk = file.read(10)
    if not chunk: break
    print(chunk)

'''
#Функция range
'''
Один аргумент генерирует список от нуля до указанного(не включая его), два аргумента
первый будет как нижняя граница а второй как верхняя, третий аргумент - шаг.
например значения в порядке убывания с шагом -1, list(range(5,-5,-1))

Управление индексами вручную в цикле for:
x = 'spam'
len(x)
list(range(len(x)))
for i in range(len(x)): print(x[i], end=' ')
здесь выполняется обход списка смещений в строке x, а не фактических элементов строки.

Обход части последовательности - range и срезы
например выбор каждой второй строки при обходе списка значений сгенерированных range
S = 'abcdefghijk'
list(range(0, len(S), 2))
for i in range(0, len(S), 2): print(S[i], end=' ')

Но все же лучшим способом будет срез следующего вида
S = 'abcdefghijk'
for c in S[::2]: print(c, end=' ')
'''

#обход нескольких последовательностей параллельно
'''
L1 = []; L2 = []
list(zip(L1,L2))

for (x, y) in zip(L1, L2):
    print(x, y, '--', x+y)
'''
#Генерирование индексов и элементов с помощью enumerate
'''
Традиционный способ получения индекса
x = 'spam'; offset = 0
for item in x:
    print(item, 'appears at offset', offset)
    offset += 1
способ с помощью enumerate
X = 'spam'
for (offset, item) in enumerate(X):
    print(item, 'appears at offset', offset)

enumerate возвращает объект-генератор,имеет метод __next__, вызываемый встроенной функцией 
next и возвращающий кортеж (index, value) для каждого элемента списка. 
Мы можем использовать эти кортежи для присваивания в цикле for
[c * i for (i, c) in enumerate(S)]
'''

#Итераторы и генераторы
'''
протокол итераций, реализует метод __next__, который возвращает следующее значение и возбуждает
исключение stopiteration в конце серии результатов.
f = open('file.py')
f.__next__()
функция next(x) равносильна методу __next__
f = open('file.py')
next(f)

L = [1,2,3]
I = iter(L)
I.__next__() #возвращает обьект из L

#Обход ключей словаря
D = {'a':1,'b':2,'c':3}
for key in D.keys():
    print(key,D[key])

Генераторы списков
записываются в квадратных скобках потому что это способ создания нового списка.Они выполняются быстрее чем цикл for. 
Пример работы с файлами
lines = [line.rstrip() for line in open('script1.py')]
Более сложный пример работы с данными
[('sys' in line, line[0]) for line in open('script1.py)]
Добавление проверки при генерации списка
lines = [line.rstrip() for line in open('script1.py') if line[0] == 'p']
Содержащие вложенные циклы 
[x + y for x in 'abc' for y in 'lmn'] #синтаксис допускает использовать люб колво операторов

Интересно что любые инструменты выполняющие обход слева направо используют итерационый протокол по определению при работе с обьектами
например:
list(open('script1.py'))
'&&'.join(open('script1.py'))

Итераторы представлений словарей
D = dict(a=1. b=2, c=3)
K = D.keys() #возвращает ключи из D - a,b,c
V = D.values() #возвращает значения ключей a,b,c
с помощью iter словари могут итерироваться

for и итераторы связаны тем что для обхода эл-ов используется метод __iter__ обьекта.
for и генераторы списков взаимосвязаны тем что генераторы всегда можно преобраз в for.
Для оптимального построчного чтения файлов явл исп генератора списков или for, т.к. исп метод __next__
'''

'''
Документация
# - для комментария
функция dir позволяет получить список всех атрибутов обьекта(методов и элементов)
Например модуль sys или string
import sys
print(dir(sys))
Также можно получить атрибуты с помощью литерала :
print(dir([])) или print(dir(''))

Если текст в файле был задокументирован с помощью кавычек ''' ''' то импортировав файл и модуль docstrings можно
получить текст, атрибут выполн вывод - __doc__
Пример:
import docstrings
print(docstrings.__doc__)
print(docstrings.function.__doc__)
'''