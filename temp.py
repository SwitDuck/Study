# -*- coding: utf-8 -*-

#Неизменяемые типы - числа,строки,кортежи; изменяемые - списки и словари
##Присваивание кортежей
'''for (a,b,c) in [(1,2,3), (4,5,6), (7,8,9)]:
    print(b)
for ((a,b),c) in [((1,2),3), ((4,5),6), ((7,8),9)]:
    print(a)
'''

##range(n) - создание непрерывного списка чисел 1-n

##разделение последовательности на начальную и остальную части в цикле
""" L = list(range(10))
while L:
    front, L = L[0], L[1:]
    print(front, L)
"""

##Расширенная операция распаковывания(работает как с кортежами,числами,списками,строками)
'''
seq = [1,2,3,4]
a, *b = seq
print(a, b)
*a, b = seq
print(a, b)

#извлечение среза
S = 'spam'
S[0], S[1:3], S[3]
'''

##Экранирование последовательности
'''
\a
\b
\'
\\
\n
\f
'''
#path = r'C:\Users\Здравствуйте господи\Desktop\Новая папка\data.txt'
#print(path)
#print('try to {0} the {1}'.format('format', 'strings'))


#Спецификаторы формата
'''
В общем виде синтаксис использования спецификатора формата 
выглядит следующим образом:
    %[(name)][flags][width][.precision]code
Символ спецификатора формата (code) из табл. 7.4 располагается в самом кон-
це.
'''
'''
x = 1.23456789 
print('%e | %f | %g' % (x, x, x))
print('%E' % x)
'''
'''
reply = """                # Шаблон с замещаемыми спецификаторами формата
Greetings...
Hello %(name)s!
Your age squared is %(age)s
"""
values = {'name': 'Bob', 'age': 40}   
print(reply % values) 
'''

'''
Как и оператор форматирования %, метод format обладает дополнительными 
возможностями. Например, в строках формата допускается ссылаться на име-
на атрибутов объектов и ключи словарей, – как и в привычном синтаксисе 
языка PPyython, квадратные скобки обозначают ключи словаря, а точка приме-

thon,,  квадратные скобки обозначают ключи словаря, а точка приме-

квадратные скобки обозначают ключи словаря, а точка приме-
няется для организации доступа к атрибутам объектов, на которые ссылаются 
позиционные или именованные спецификаторы
'''
'''
import sys
'My {1[spam]} runs {0.platform}'.format(sys, {'spam': 'laptop'})
print('My {config[spam]} runs {sys.platform}'.format(sys=sys, config={'spam': 'laptop'}))
'''

#Обьект кортеж tuple
'''
По сути это список который невозможно изменить.Необходимы когда треб фиксированные ассоциации обьектов.
Но это касается только самих кортежей, но не к обьектам которые он содержит.Т.е можно изменить вложенный обьект
T = (1,[2,3],4)
T[1][0] = 'spam'
Являются колекциями обьектов упорядоченных по позициям(слева направо).
Поддерживают все операции которые основаны на использовании смещения,такие как индексирование 
и извлечение среза.
Подобно спискам проще представлять как массивы ссылок на обьекты, кортежи хранят указатели на другие обьекты
а операция индексирования над ними выполняется очень быстро
T = () - пустой кортеж, T = ('abc', ('def', 'ghi')) - вложенный кортеж
Чтобы интерпретатор понял что это именно кортеж нужно после элемента поставить ',' т.е T=(1,)
'''
'''new_tuple = ('spam',3,4,5,[11,22,33])'''
'''
Операции над кортежами
T = tuple('spam') - создание кортежа из итерируемого обьекта
T[i], T[i][j], T[i:j]

len(T) - размер кортежа

T1+T2, T1*3 - конкатенация и повторение

Обход в цикле, проверка вхождения
for x in T : print(X)
'spam' in t2
[x**2 for x in T]

Поиск и подсчет вхождений
T.index(value) - первое вхождение в позиции value, T.index(value,value) - следующее вхождение за позицией value
T.count(value) - определить количество двоек в кортеже

создание списка из кортежа и кортежа из списка
tmp = list(T), T = tuple(tmp)

'''
'''Извлечцение среза'''
'''T = (1,2,3,4)
print(T[0], T[1:3])'''


#Файлы
'''
функция open() Обеспечивает свзязь с файлом,размещ на компе.

Операции над файлами
output = open(r'data.txt','w') - открывает файл для записи, w-запись
input = open('data', 'r') - открывает файл для чтения, r - чтение
aString = input.read() - чтение файла целиком в одну строку.
aString = input.read(N) - чтение следующих N символов(или байтов в строку)
aList = input.readlines() - чтение файла целиком в список строк(включая символ конца строки)
output.write(aString) - запись строки символов или байтов в файл
output.writelines(aList) - запись всех строк из списка в файл
output.close() - закрытие файла в ручную
output.flush() - выталкивает выходные буферы на диск, файл остается открытым
anyFile.seek(N) - изменяет текущую позицию в файле для следующей операции, смещая ее на N байтов от начала файла
for line in open('data.txt') - построчное чтение, в цикле
open('data.txt', encoding='latin-1') - файлы с текстом юникода(строки типа str)
open('data.bin', 'rb') - файлы с двоичными данными(строки типа bytes)
режим работы 'a' - файл открывается на запись в конец
если добавить к параметру режима работы b - то будет работа с двоичными данными
,а если + то можно будет как записывать так и читать данные
так же добавляя третий аргумент,управляющий буферизацией выводимих данных, например значение 0
будет означать что информация будет записываться в файл сразу же в момент вызова метода записи
лучше всего не использовать операцию чтения из файла, файлы имеют итератор который автоматически
читает информацию из файла строку за строкой в цикле for, в шенераторах списков и др итерац контекстах
метод seek позваоляет сценариям управлять позицией чтения и записи
\n - символ записи с новой строки, в конце

Правильная обработка текста
file_path = r'C:\Users\Здравствуйте господи\Desktop\Новая папка\data.txt'
decoded_text = []
with open(file_path, 'rb') as file:
    for line in file: decoded_text.append(line.decode('unicode_escape'))
'''