# -*- coding: utf-8 -*-

#Неизменяемые типы - числа,строки,кортежи; изменяемые - списки и словари
##Присваивание кортежей
'''for (a,b,c) in [(1,2,3), (4,5,6), (7,8,9)]:
    print(b)
for ((a,b),c) in [((1,2),3), ((4,5),6), ((7,8),9)]:
    print(a)
'''

##range(n) - создание непрерывного списка чисел 1-n

##разделение последовательности на начальную и остальную части в цикле
""" L = list(range(10))
while L:
    front, L = L[0], L[1:]
    print(front, L)
"""

##Расширенная операция распаковывания(работает как с кортежами,числами,списками,строками)
'''
seq = [1,2,3,4]
a, *b = seq
print(a, b)
*a, b = seq
print(a, b)

#извлечение среза
S = 'spam'
S[0], S[1:3], S[3]
'''

##Экранирование последовательности
'''
\a
\b
\'
\\
\n
\f
'''
#path = r'C:\Users\Здравствуйте господи\Desktop\Новая папка\data.txt'
#print(path)
#print('try to {0} the {1}'.format('format', 'strings'))


#Спецификаторы формата
'''
В общем виде синтаксис использования спецификатора формата 
выглядит следующим образом:
    %[(name)][flags][width][.precision]code
Символ спецификатора формата (code) из табл. 7.4 располагается в самом конце.
'''
'''
x = 1.23456789 
print('%e | %f | %g' % (x, x, x))
print('%E' % x)
'''
'''
reply = """                # Шаблон с замещаемыми спецификаторами формата
Greetings...
Hello %(name)s!
Your age squared is %(age)s
"""
values = {'name': 'Bob', 'age': 40}   
print(reply % values) 
'''

'''
Как и оператор форматирования %, метод format обладает дополнительными 
возможностями. Например, в строках формата допускается ссылаться на име-
на атрибутов объектов и ключи словарей, – как и в привычном синтаксисе 
языка PPyython, квадратные скобки обозначают ключи словаря, а точка приме-
няется для организации доступа к атрибутам объектов, на которые ссылаются 
позиционные или именованные спецификаторы
'''
'''
import sys
'My {1[spam]} runs {0.platform}'.format(sys, {'spam': 'laptop'})
print('My {config[spam]} runs {sys.platform}'.format(sys=sys, config={'spam': 'laptop'}))
'''

#Обьект кортеж tuple
'''
По сути это список который невозможно изменить.Необходимы когда треб фиксированные ассоциации обьектов.
Но это касается только самих кортежей, но не к обьектам которые он содержит.Т.е можно изменить вложенный обьект
T = (1,[2,3],4)
T[1][0] = 'spam'
Являются колекциями обьектов упорядоченных по позициям(слева направо).
Поддерживают все операции которые основаны на использовании смещения,такие как индексирование 
и извлечение среза.
Подобно спискам проще представлять как массивы ссылок на обьекты, кортежи хранят указатели на другие обьекты
а операция индексирования над ними выполняется очень быстро
T = () - пустой кортеж, T = ('abc', ('def', 'ghi')) - вложенный кортеж
Чтобы интерпретатор понял что это именно кортеж нужно после элемента поставить ',' т.е T=(1,)
'''
'''new_tuple = ('spam',3,4,5,[11,22,33])'''
'''
Операции над кортежами
T = tuple('spam') - создание кортежа из итерируемого обьекта
T[i], T[i][j], T[i:j]

len(T) - размер кортежа

T1+T2, T1*3 - конкатенация и повторение

Обход в цикле, проверка вхождения
for x in T : print(X)
'spam' in t2
[x**2 for x in T]

Поиск и подсчет вхождений
T.index(value) - первое вхождение в позиции value, T.index(value,value) - следующее вхождение за позицией value
T.count(value) - определить количество двоек в кортеже

создание списка из кортежа и кортежа из списка
tmp = list(T), T = tuple(tmp)

'''
'''Извлечцение среза'''
'''T = (1,2,3,4)
print(T[0], T[1:3])'''


#Файлы
'''
функция open() Обеспечивает свзязь с файлом,размещ на компе.

Операции над файлами
output = open(r'data.txt','w') - открывает файл для записи, w-запись
input = open('data', 'r') - открывает файл для чтения, r - чтение
aString = input.read() - чтение файла целиком в одну строку.
aString = input.read(N) - чтение следующих N символов(или байтов в строку)
aList = input.readlines() - чтение файла целиком в список строк(включая символ конца строки)
output.write(aString) - запись строки символов или байтов в файл
output.writelines(aList) - запись всех строк из списка в файл
output.close() - закрытие файла в ручную
output.flush() - выталкивает выходные буферы на диск, файл остается открытым
anyFile.seek(N) - изменяет текущую позицию в файле для следующей операции, смещая ее на N байтов от начала файла
for line in open('data.txt') - построчное чтение, в цикле
open('data.txt', encoding='latin-1') - файлы с текстом юникода(строки типа str)
open('data.bin', 'rb') - файлы с двоичными данными(строки типа bytes)
режим работы 'a' - файл открывается на запись в конец
если добавить к параметру режима работы b - то будет работа с двоичными данными
,а если + то можно будет как записывать так и читать данные
так же добавляя третий аргумент,управляющий буферизацией выводимих данных, например значение 0
будет означать что информация будет записываться в файл сразу же в момент вызова метода записи
лучше всего не использовать операцию чтения из файла, файлы имеют итератор который автоматически
читает информацию из файла строку за строкой в цикле for, в генераторах списков и др итерац контекстах
метод seek позваоляет сценариям управлять позицией чтения и записи
\n - символ записи с новой строки, в конце
функция eval выполнит любовое выражение на python. Она предназначена для преобразует список и словарь(интерпретирует строку как програмный код)

Правильная обработка текста
file_path = r'C:\Users\Здравствуйте господи\Desktop\Новая папка\data.txt'
decoded_text = []
with open(file_path, 'rb') as file:
    for line in file: decoded_text.append(line.decode('unicode_escape'))
'''

###Сохранение обьектов с помощью модуля pickle
'''
Модуль pickle позволяет сохранять в файлах практически любые обьекты python без необх с нашей
стороны выполнять какие либо преобразования.Например сохранение словаря в файле:
D = {'a':1, 'b':2}
F=open('datafile.pkl', 'wb')
import pickle
pickle.dump(D,F)
F.close()
F=open('datafile.pkl', 'rb')
E = pickle.load(F)
Т.о мы получаем точно такой же обьект словаря без необх преобразования, т.е происходит сериализация
обьектов(преобраз обьектов в строку байтов и обратно)
Если выполнить open('datafile.plk', 'rb').read() то получим строку байтов
shelve - сохранение обьектов в файлах с доступом по ключу
'''

#Сохранение и интерпретация упакованных двоичных данных в файлах
'''
иногда приходится иметь дело с упакованными двоичными данными.Стандартная библиотека python 
позволяет сохранять и восстанавливать такие данные с помощью модуля struct
Пример:строка формата,которая определяет пакет данных содержащий 4-байтовое целое число, 4 символьную строку и 2 байтовое целое число
причем все представлены в формате следования байтов от старшего к младшему
import struct
F = open('data.bin', 'wb')
data = struct.pack('>i4sh', 7, b'spam', 8)
F.write(data)
F.close()
F = open('data.bin', 'rb')
data = F.read()  
F.close()
values = struct.unpack('>i4sh', data)
print(values)
'''

#Ссылки на обьекты
'''
Вот мы создали 2 списка и 1 словарь.L и D содержат ссылки на словарь X.
X = [1, 2, 3]
L = ['a', X, 'b']
D = {'x':X,'y':2}
Если внести изменения в X, то это приведет к изменению всех трех ссылок - X,L И D.
X[1]='surprise'
print(L)
print(D)
Ссылки более высокоуровненвый аналог указателей в других языках, эта особенность позволяет передавать
крупные обьекты между компонентами программы без выполнения дорогостоящей операции копирования.
В случае если нужно создать не ссылающуюся копию обьекта то можно использовать методы:
1) извлечение среза с пустыми пределами A = L[:]
2) словарей и множеств copy - B = D.copy()
однако copy создает поверхностные копии которые не копируют вложенные структуры данных, если
это нужно то использутется метод deepcopy
import copy
X = copy.deepcopy(Y)
'''

#Сравнивание,равенство и истина
'''
L1 = []
L2 = []
L1 == L2, L1 is L2 # == - интерпретатор выполняет проверку на равенство, рекурсивно сравнивая
все вложенные обьекты. is - проверяет являются ли сравниваемые обьекты одним и тем же обьектом.
сравнения <,==,>. строки сравниваются символ за символом, слева направо, 
словари сравниваются как отсортированные списки(ключ,значение)
однако в py 3.0 поддержка операторов отношений в словарях была ликвидирована.
Поэтому используются циклы.
list(D1.items()) < или > sorted(D2.items())

правда и ложь в python реализована как ложь - значения пустых списков/нули/None, правда - имеющих символы/1-9 цифры

'''

#Вывод текста,расширенное применение метода print
'''
print([object, ...][, sep=' '][, end='\n'][, file=sys.stdout])
здесь object - выводимые обьекты
sep - строка которая должна вставляться между выводимыми обьектами
end - строка добавляемая в конец выводимого текста
file - обьект файла,поток или другой обьект куда будет выводиться текст.
пример
print(x,y,z, sep=',', end='!\n', file=open('data.txt', 'w'))
print(open('data.txt').read())
стоит отметить что sys.stdout - параметр вывода по умолчанию
и его можно перенаправить в другое русло,например вывод в логи
import sys
sys.stdout = open('log.txt', 'a')
print(x,y,z)
sys.stdout.close()

или sys.stderr.write(('bad!'*8)+'\n') эквивалентно
print('bad!'*8, file=sys.stderr)
'''

#If и синтаксические правила
'''
if(условие):
    действие
elif(условие):
    действие
else:
    действие
логические операторы - and, or, not(and - если истина 2 значения, or - истина если любое,)

в случае оператора or интерпретатор начинает вычислять значения обьектов слева направо и 
возвращает первое истинное значение. Например 2 or 3, 3 or 2 - Вернет соответственно (2, 3)

and - останавливает вычисление когда найдется первый обьект имеющий ложное значение
краткая форма записи if/else
A = 't' if 'spam' else 'f'
A = 't' if '' else 'f'
Другая форма записи этих выражений
['f', 't'][bool('')]
['f', 't'][bool('spam')]
'''

#Циклы while и for
'''
while <test1>:
    <statements1>
    if <test2>: break
    if <test3>: continue
else:
    <statements2>
'''
#for
'''
циклы удобно использовать там где надо повторно выполнять некоторые действия или обрабатывать
данные. Вот пример посимвольного чтения.
file = open('test.txt')
while True:
    char = file.read(1)
    if not char: break
    print(char)
for char in open('test.txt').read()
    print(char)
Чтение строками или блоками
file = open('test.txt')
while True:
    line = file.readline()
    if not line:break
    print(line, end=' ')
file.close

file = open('test.txt', 'rb')
while True:
    chunk = file.read(10)
    if not chunk: break
    print(chunk)

'''
#Функция range
'''
Один аргумент генерирует список от нуля до указанного(не включая его), два аргумента
первый будет как нижняя граница а второй как верхняя, третий аргумент - шаг.
например значения в порядке убывания с шагом -1, list(range(5,-5,-1))

Управление индексами вручную в цикле for:
x = 'spam'
len(x)
list(range(len(x)))
for i in range(len(x)): print(x[i], end=' ')
здесь выполняется обход списка смещений в строке x, а не фактических элементов строки.

Обход части последовательности - range и срезы
например выбор каждой второй строки при обходе списка значений сгенерированных range
S = 'abcdefghijk'
list(range(0, len(S), 2))
for i in range(0, len(S), 2): print(S[i], end=' ')

Но все же лучшим способом будет срез следующего вида
S = 'abcdefghijk'
for c in S[::2]: print(c, end=' ')
'''

#обход нескольких последовательностей параллельно
'''
L1 = []; L2 = []
list(zip(L1,L2))

for (x, y) in zip(L1, L2):
    print(x, y, '--', x+y)
'''
#Генерирование индексов и элементов с помощью enumerate
'''
Традиционный способ получения индекса
x = 'spam'; offset = 0
for item in x:
    print(item, 'appears at offset', offset)
    offset += 1
способ с помощью enumerate
X = 'spam'
for (offset, item) in enumerate(X):
    print(item, 'appears at offset', offset)

enumerate возвращает объект-генератор,имеет метод __next__, вызываемый встроенной функцией 
next и возвращающий кортеж (index, value) для каждого элемента списка. 
Мы можем использовать эти кортежи для присваивания в цикле for
[c * i for (i, c) in enumerate(S)]
'''

#Итераторы и генераторы
'''
протокол итераций, реализует метод __next__, который возвращает следующее значение и возбуждает
исключение stopiteration в конце серии результатов.
f = open('file.py')
f.__next__()
функция next(x) равносильна методу __next__
f = open('file.py')
next(f)

L = [1,2,3]
I = iter(L)
I.__next__() #возвращает обьект из L

#Обход ключей словаря
D = {'a':1,'b':2,'c':3}
for key in D.keys():
    print(key,D[key])

Генераторы списков
записываются в квадратных скобках потому что это способ создания нового списка.Они выполняются быстрее чем цикл for. 
Пример работы с файлами
lines = [line.rstrip() for line in open('script1.py')]
Более сложный пример работы с данными
[('sys' in line, line[0]) for line in open('script1.py)]
Добавление проверки при генерации списка
lines = [line.rstrip() for line in open('script1.py') if line[0] == 'p']
Содержащие вложенные циклы 
[x + y for x in 'abc' for y in 'lmn'] #синтаксис допускает использовать люб колво операторов

Интересно что любые инструменты выполняющие обход слева направо используют итерационый протокол по определению при работе с обьектами
например:
list(open('script1.py'))
'&&'.join(open('script1.py'))

Итераторы представлений словарей
D = dict(a=1, b=2, c=3)
K = D.keys() #возвращает ключи из D - a,b,c
V = D.values() #возвращает значения ключей a,b,c
с помощью iter словари могут итерироваться

for и итераторы связаны тем что для обхода эл-ов используется метод __iter__ обьекта.
for и генераторы списков взаимосвязаны тем что генераторы всегда можно преобраз в for.
Для оптимального построчного чтения файлов явл исп генератора списков или for, т.к. исп метод __next__
'''

'''
Документация
# - для комментария
функция dir позволяет получить список всех атрибутов обьекта(методов и элементов)
Например модуль sys или string
import sys
print(dir(sys))
Также можно получить атрибуты с помощью литерала :
print(dir([])) или print(dir(''))

Если текст в файле был задокументирован с помощью кавычек ''' ''' то импортировав файл и модуль docstrings можно
получить текст, атрибут выполн вывод - __doc__
Пример:
import docstrings
print(docstrings.__doc__)
print(docstrings.function.__doc__)
'''

#функции
'''
Функция является способом группирования набора операторов, позволяющим выполнять их более одного раза
в программе — упакованной процедурой, вызываемой по имени.
предназначена для доведения до максимума многократного использования кода и подводит нас к более 
широким понятиям проектирования программ.
Операторы и выражения:
-def пример:
def printer(messegae):
    print('hello ' + message)
Является исполняемым кодом.def - исполняемый оператор, ф-ия не сущ пока python не встретит и не выполнит ф-ию
def законно вкладывать внутрь if/else, while, файлов, И даже др ф-ий.

-return пример:
def adder(a, b=1, *c):
    return a+b+c[0]
return отправляет результирующий объект вызывающему коду. Когда функция вызывается, 
вызывающий код приостанавливается до тех пор, пока функция не завершит свою работу
 и не возвратит управление обратно.

-global
x='old'
def changer():
    global x; x = 'new'
global объявляет переменные уровня модуля, предназначенные для присваивания.
По умолчанию имена присваемые в функции сущ только во время выполн.
    
-nonlocal
def outer():
    x = 'old'
    def changer():
        nonlocal = x; x = 'new'
nonlocal объявляет переменные объемлющей функции, предназначенные
для присваивания;
В отличие от оператора global к моменту вы­полнения оператора nonlocal перечисленным в нем именам действительно должны 
быть присвоены значения в области видимости объемлющего def;
Оператор nonlocal ограничивает поиск в областях видимости только объемлющими def;
Нелокальные переменные не ищутся в глобальной области види­мости включающего модуля 
или во встроенной области видимости за пределами всех def;

-yield
def squares(x):
    for i in range(x): yield i ** 2
yield отправляет результирующий объект вызывающему коду, но запоминает место, где он остановился.
Нужно для предосохранения состояния и возобновлять работу

-lambda
funcs = [lambda x: x**2, lambda x: x**3]
lambda — средства, которое позволяет
встраивать определения функций в места, где оператор def синтаксически не допускается. 
Создает обьект но возвращает его в качестве результата

Из-за того, что Python являет­
ся динамически типизируемым языком, полиморфизм в нем буквально процветает. 
Фактически каждая операция в Python обладает полиморфизмом: вывод, индексация, 
операция * и многие другие.

глобальными переменными называются переменные в __main__ файле, 
при импортировании модуля они становятся атрибутами
Локальные переменные присутствуют внутри цикла и функции, переменные внутри функции можно сделать глобальными
с помощью оператора global.
При вызове функции создается локальная область видимости

модули также можно импортировать в функции, ограничивая обл видимости

В функциях можно свободно использовать имена, присвоенные в синтак­
сически объемлющих функциях и глобальной области видимости, но для изменения 
таких имен они должны быть объявлены как нелокальные и глобальные.

Оператор global
Глобальные имена должны объявляться, только если им выполняются присваи­
вания внутри функции.
На глобальные имена можно ссылаться внутри функции без их объявления
X = 88
def func():
    global X
    X = 99
func()
print(X)

Порядок аргументов функции имеет значение. Первыми должны идти позиционные и именованные аргументы.
Затем идут произвольные аргументы *arg. Затем только именованные. Затем произвольное ключевое слово **kwargs
def func(arg1, arg2=10, *args, kwarg1, kwarg2=2, **kwargs):
arg 1 должен быть задан как позиционный или как именованный, чтобы не было typeerror
kwarg1 должен быть задан, только именованным func(kwarg1=10)
arg2 и kwarg2, необязательные, но задаются по тем же правилам что и выше

Лямбда функции применение:
интерактивно 
key = 'got'
{'already':(lambda: 2+2), 'got':(lambda: 2*4), 'one':(lambda: 2**6)}[key]()
#в этом примере происходит индексация по ключу и извлечение одной из функций

второй более сложный пример
import sys
showall = lambda x: list(map(sys.stdout.write, x))
t = showall(['spam\n', 'toast\n', 'eggs\n'])

Также функция lambda имеет доступ к именам в любой обьемлющей функции lambda(правило LEGB)
Пример
action = (lambda x: (lambda y: x+y))
то есть при вызове функция lambda y будет иметь доступ к именам lambda x

Использование lamdba в модуле tkinter
- определение внутристрочных функций обратного вызова.
Пример создание кнопки вывода сообщений
import sys
from tkinter import button, mainloop
x = Button(text='Press me', command=(lambda:sys.stdout.write('Spam\n')))
x.pack()
mainloop()
Преимущество данного способа в том что код обработчик находится прямо в вызове, создающем кнопку.
lambda откладывет выполнение обработчика до возникновения события.

'''

'''
Функциональное программироввание
- инструменты которые применияют функции к последовательностям и другим итерируемым оъектам.
map(), filter(), reduce()
функция map применяет передвнную функцию к каждому элементу в итерируемом обьекте.
counters = [1,2,3,4]
def inc(x): return x + 10
list(map(inc, counters))
list (map ((lambda x: x + 3) , counters))
Пример утилита отображения
def mymap(func, seq):
    res = []
    for x in seq: res.append(func(x))
    return res
 Функция filter
 функция filter и reduce выбирают элементы из итер. обьектов на основе проверочной функции и применяют к парам элементов
 Пример list(filter(lambda x:x>0), range(-5,5)))
 Функция reduce не является итерируемым обьектом а возвращает одиночный результат.
from functools import reduce
reduce((lambda x,y :x+y), [1,2,3,4])
инициализир с 1 элемента последовательности 
Эквивалентная версия ф-ии reduce
def myreduce(function, sequence):
    tally = sequence[0]
    for next in sequence[1:]:
        tally = function(tally,next)
    return tally

Вместо лямбда функции можно использовать оператор(operator)
Например operator.add из модуля operator
'''

'''
Регулярные  выражения
Это шаблон применяемый для поиска совпадающих с ним фрагментов в строках;
Для этого используется модуль re;
Регулярное выражение создается с помощью функции compile().Ее формат:
re.compile(<шаблон регулярного выражения>[, <флаги>])
I(IGNORECASE) - регистр символов не учитывается;
p = re.compile(r"^[а-яе]+$", re.I | re.U)
M(MULTILINE)- поиск в каждой подстроке с начала и до конца: ^ - символ начала подстроки в строке, $ - конец;
p = re.compile(r"^.*$", re.M)
S(DOTALL) - метасимвол точка, соответствует любому символу включая перевод строки;
p=re.compile(r"^.*$", re.S)
X(VERBOSE) - пробелы, символы перевода строки и коментарии в этом шаблоне игнорируются;
p = re.compile(r"""^[0-9]+$""", re.X | re.S)
A(ASCII) - классы \w,\W,\B,\b,\d,\D,\s,\S - соотв символам в кодировке Ascii;
В квадратных скобках [] указываются символы которые могут встречаться в строке или диапазон символов через дефис;

'''

'''
Аргументы функции.
Ключевые аспекты передачи аргументов функции:
1) аргументы передаются путем автоматического присваивания объектов именам локальных переменных;
2)Присваивание именам аргументов внутри функции не затрагивает вызывающий код;
3)Модификация внутри функции аргумента являющегося изменяемым объектом может затронуть вызывающий код;
Схема передачи по присваиванию python
1)Неизменяемые аргументы передаются по значению, обьекты подобные целым числам и строкам передаются по ссылке на объекты
не путем копирования;
2)Изменяемые аргументы фактически передаются по указателю, объекты подобные списков и словарей передаются по
ссылке на объекты, их можно изменять на месте функции
Пример описание
def changer(a,b):
    a = 2
    b[0] = 'spam'
X = 1; L= [1,2];
changer(X,L); print(X,L)
#Выведится 1, ['spam', 2]  //это означает изменился только список - изменяемый обьект
На самом же деле ф-ия не изменяет b, - она только модифицирует часть объекта на который ссылается b в текущий момент;
Однако если изменение не требуется можно создать копию списка внутри самой функции,
в крайнем случае привети список к кортежу;

Сопоставление аргументов. Режимы:
1)Позиционные - сопоставляются слева направо(сопоставление переданных значений аргументов с именами аргументов
в заголовке функции)
2)Ключевые - сопоставляются по имени аргумента(посредством синтаксиса вида имя=значение);
3)СТандартные - указывают значения для необязательных аргументов, которым значения не передавались
4)Сбор переменного количества аргументов(собирает произвольно много позиционных и ключевых аргументов)
применяются спец аргументы с * или ** звездочками(varags);
5)Распаковка переменного количества аргументов(* в вызове функции)
6)Аргументы с передачей только по ключевым словам
Расширения ** не только работает с ключевыми аргументами - оно собирает их в словарь, который потом можно обрабатывать;
#Пример1
def f(**args):print(args)
f(a=1,b=2) -> {'a':1, 'b':2}

#Пример2
def f(a, *pargs, **kargs):print(a,pargs,kargs)

#Пример распаковка
args = {'a':1, 'b':2, 'c':3}
args['d'] = 4
def func(a,b,c,d):print(a,b,c,d)
func(**args)
ТО ЕСТЬ РАЗНИЦА В ТОМ ЧТО * - ПОЗИЦИОННЫЕ(очередь), ** - КЛЮЧЕВЫЕ АРГУМЕНТЫ(явно с именами);
'''